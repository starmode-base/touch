---
alwaysApply: true
---

SUPER IMPORTANT: ALWAYS FOLLOW THESE RULES CAREFULLY UNLESS THE USER EXPLICITLY SAYS NOT TO. IF YOU ARE UNSURE, THESE RULES WIN.

# Constraints

- NEVER modify files or run tools unless explicitly instructed by the user. When in doubt, ask; default to no edits.
- MUST implement only explicitly requested requirements. NO speculative features or abstractions.
- MUST avoid premature optimizations. Optimize only when a measurable bottleneck is identified.
- NO speculative checks. ONLY guard errors that can actually occur.
- MUST validate external data with Zod: raw API responses, user input. Trust typed SDK responses.
- MUST use runtime checks for type narrowing (instanceof, typeof, in, Array.isArray, Zod). NEVER use type assertions (`as SomeType`) or type predicates (`value is SomeType`) unless explicitly instructed.
- MUST fail fast on missing/invalid required data. NEVER invent defaults, speculative fallbacks, or silent recovery.
- NO `?? ""` or arbitrary fallbacks. Make values required or fail fast if missing.
- NEVER make args/params/props optional unless absence has domain meaning.

# Code style

- Write functional style code (immutable, pure functions).
- Use imperative style (for-loops, local mutation, classes) ONLY when necessary.
- For all imperative code, write comments explaining why it is chosen over functional style.
- NEVER export symbols that aren't imported anywhere.
- Treat acronyms as words in camelCase/PascalCase (`useE2ee`, not `useE2EE`).

# Testability

- Write code that is testable without mocks; create factories at boundaries.

# Testing

CRITICALLY IMPORTANT: Write tests based on expected behavior/requirements, NOT the current implementation. A failing test reveals bugs in the code, which is a good thing.

- Assert observable behavior only: API responses, DB state after actions. NEVER inspect internals (private functions, in-memory variables).
- Query DB in tests when persistence is part of the contract (auth, idempotency, transactions).
- Tests MUST be deterministic (fixed time/randomness), isolated (no cross-test state; parallel-safe), and minimal (only setup what's needed).
- Keep setup (data, fixtures, helpers) local to each test file. NO global mutable fixtures.
- Avoid mocks; mock external boundaries only when necessary.
- Use one top-level `describe` per function or unit under test.
- Use `test()` instead of `it()`.
- Test names should follow a subject-based pattern: start with who/what, then state the expected behavior (e.g., "unauthenticated user is rejected", "administrator can update organization").
- Order tests within each describe block from negative (expected failures) to positive (happy path).
- It's okay to disable lint rules in test files if needed.
- Use `describe.each` or `test.each` when validating the same logic across multiple inputs.
- Prefer `{ label, input, expected }` objects for parameterized test cases.
- Use names (characters, planets, space stations, spaceships) from the Aliens (1986) movie.

# Documentation

- Always use sentence case for titles (never title case).
- In code comments with _one_ sentence, omit the period.

# Drizzle ORM / Postgres

When working with Drizzle ORM and database schemas:

- NEVER create migrations - the user will generate migrations.
- NEVER modify `src/postgres/relations.ts`.
- MUST enforce data integrity with database constraints: unique values get unique constraints, required values get NOT NULL. Application code has bugs; database constraints never lie.
